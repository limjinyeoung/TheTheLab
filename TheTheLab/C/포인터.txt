포인터는 왜 사용하는가?
-> C언어에서는 다른 함수에서 다른 함수의 변수값을 변경하는 것이 불가능하다.
=> 함수의 컨텍스트가 다르기 때문이다. (call-by-value가 일어남)

포인터를 사용하면 어떻게 되는가?
-> 포인터 변수에 변수의 값이 아닌 변수의 주소를 저장한다. (call-by-reference)
=> 주소를 저장하기 위한 타입을 포인터 타입이라고 한다. 포인터 타입 변수의 크기는 8바이트이다.

%p : 주소(포인터)를 출력하기 위한 서식

int* : int의 주소를 저장하기 위한 타입

int** : int*의 주소를 저장하기 위한 타입



포인터 변수는 추가적인 연산을 허용하는데, 


int n = 42;
int *p = &n;
*p = 100	// 컴파일러가 *p를 n으로 해석하여 n = 100으로 해석함.







int a = 10;
int *p;
p = &a;		//	a = *p = 10	&a = p = 주소




int a = 10;
int *p = &a;		//	a = *p = 10	&a = p = 주소       






배열과 포인터
-> 배열은 배열의 첫번째 원소의 시작 주소가 전달된다. // arr -> int arr[] -> &arr[0] -> int *arr
-> 다른 함수에서 전달된 배열의 크기를 알 수 없다.

이차원배열 int arr[3][10]에서는?
-> arr의 타입은 int[3][10]이다.
-> arr은 3개 짜리 배열이다.	(3개짜리 배열 안에 10개씩의 배열이 있다.)
-> arr[0]의 타입은 int[10]이다.
=> 배열의 이름은 배열의 첫번째 원소의 시작 주소(&arr[0] = &arr[0] = int[10]*)로 해석된다.
=> 배열의 []기호는 반드시 심볼 뒤에 와야 한다. (int *p[10])
=> 우선순위에 따라 괄호로 묶어주어야 한다. 	int (*p)[10]

-> arr[3] = {1, 2, 3}일 때
=> arr : 배열의 첫번째 원소의 시작주소. = &arr[0] (~>int*)
   &arr ~> int (*p)[3] 	// 3개짜리 배열을 가리키는 포인터. 	(*p)[0] = 10;
   arr  ~> int *p 	// 배열의 첫번째 원소의 시작주소.	p[0] = 10	*(p+0) = 10
	





int a[3] = {10, 20, 30};
int *p = a;		//	a[0] = *a = *p = 10	a[1] = *(a+1) = *(p+1) = 20	a = p = 주소	
				포인터의 연산은 상수와의 +-밖에 가능하지 않다.
				*****포인터 - 포인터 = 주소값 차 / 대상체 타입 크기




int *a => a[i]
&a[i] => *p



호출하는 함수에서는 
func(arr) 로 배열의 주소를 전달하거나
func(&a) 로 데이터의 주소를 전달한다.
함수의 매게 변수가 포인터이므로 반드시 주소를 전달해야 한다.

호출당하는 함수에서는
func(int *arr) 또는 func(int arr[]) 로 주소를 포인터로 전달받아 저장한다. 
포인터는 주소만 저장할 수 있기 때문에 이 함수를 호출하기위해서는 반드시 주소를 전달해야 한다.





int * const pa   => 값을 바꾸거나 포인터를 이동시킬 수 없음
int const *pa    => 포인터를 이동시킬 수 있으나 대상체를 바꿀 수 없음
*뒤에 const가 있으면 포인터 이동 불가.
*앞에 const가 있으면 대상체 바꿀 수 없음.
