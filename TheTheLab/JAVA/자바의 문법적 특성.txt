for(int i = 0; i <100; i++) {
	Creator c = new Creator();
}
====>만약 {}가 없다면 빨간줄
**자바의 문법적 특성 : while / for 반복문 뒤에서
	 지역변수 선언을 블럭처리없이 한문장으로 사용할 수 없다.






final의 특징.****필드와 메서드, 클래스에 적용하는 경우에 다른 결과를 보인다.
1.final이 클래스앞에 붙을 경우	 	상속 불가
2.final이 필드 앞에 붙을 경우	 	수정 불가(초기화만 가능)
3.final이 메서드 앞에 붙은 경우  	오버라이딩 불가








상속받을 경우, 메소드의이름이 같을 때, 자식클래스의 메소드의 접근제한자가 좁아질 수는 없다.
(필드는 가능)









class X {
	static class Y {
		static String Z = "Black";
	}
	
	static Clazz Y = new Clazz();
}

class Clazz {
	String Z = "White";
}
//		===>오류 안남

public class Sample {
	public static void main(String args[]) {
		System.out.println(X.Y.Z);
	}
}
//		===>White 출력

***변수 이름과 클래스 이름이 같으면서 같은 공간에 있는 경우 변수의 이름을 우선적으로 사용한다.
	->변수의 이름이 클래스 이름을 모호화 한다.
	-->자바의 네이밍 컨벤션을 지키면 해결된다.








-1
= 0x 1111 1111 1111 1111 1111 1111 1111 1111


(byte)-1
= 0x 1111 1111				//byte의 자료형이면 부호의 확장이 일어난다.


(char)0x 1111 1111
= 0x 1111 1111 1111 1111		//char의 자료형이면 0의 확장이 일어난다.

(int)0x 1111 1111 1111 1111
= 0x 0000 0000 0000 0000 1111 1111 1111 1111


****부호가 있는 자료형이라면 부호의 확장이 일어남.(byte, int)
	그렇지 않다면 0의 확장이 일어남(char)







short x = 0;
int i = 123456;

x += i; 	//오류 없음. (복합할당 연산자는 왼쪽 변수의 자료형으로 변환된다.) 그러나 쓰레기 값이 나옴.
x = x + i;	//에러 뜸 