reference Counting(참조 계수) : 해당 객체를 참조하는 변수의 개수를 counting

 *객체의 생성과 소멸 (garbage collector :파괴될 객체를 모아두고 일괄적으로 파괴 -> 메모리 수거)이 원활해야 됨.

-얕은 복사(레퍼런스) : 속도가 빠르고, 메모리도 덜 쓴다. // 오버헤드가 있다.*****객체의 파괴 시점을 결정할 수 없다.(댕글링 포인터)*****

-깊은 복사(값) : 속도가 느리고, 메모리 소모가 많다. // 객체의 파괴 시점을 결정할 수 없다.

*****댕글링포인터(참조변수가 있지만 객체가 사라짐) 해결 방법***** 
참조계수에 의한 객체 수명 관리 : 객체의 파괴시점을 명확하게 하기 위해서 참조계수에 의해 객체 수명을 관리함.
-객체가 생성되면 참조계수는 1이다.
-객체 참조가 복사되면, 참조계수는 증가한다.
-모든 객체 참조가 사라지면, 객체는 사라진다.
*GC가 동작하는 시점은 정확히 알 수 없다. (System.gc()도 무조건 GC를 수행하는건 아니다.)



참조계수를 관리하는 방법
1. Garbage Collection (Java, Go, C#, Javascript) : 런타임에 별도의 프로그램이 객체의 수거를 담당한다.
	- 장점 : 런타임에 GC가 판단해서 수거하므로, 유연하게 동작한다.
	- 단점 : GC가 발생하면, 프로그램의 성능이 저하된다.
2. ARC (Swift) : 컴파일 타임에 객체의 참조 계수를 관리하는 코드를 삽입한다.
	- 장점 : 빠르게 동작한다.
	- 단점 : 제대로 된 코드를 작성하지 않으면, 정상적으로 객체의 메모리가 수거되지 않는다.


strong Reference는 레퍼런싱하는동안은 GC의 수거대상이 되지 않는다. 가용한 메모리가 없을 경우, out of memory가 발생한다.
soft Reference는 out of memory에 가까워지면 메모리를 수거한다. 
weak Reference는 GC가 실행될때 메모리를 수거한다. (댕글링포인터가 발생하면 참조변수를 null로 바꿈)


**비메모리 자원(file, thread등 운영체제가 제공하는 자원)은 반드시 명시적인 종료 메소드를 통해 해지해주어야 한다.
-Try with Resources 문법을 사용할 수 있도록 AutoClosable에 대한 인터페이스 구현도 제공해야 한다.
-비메모리 자원에 대한 누수가 명시적인 종료 메소드를 호출하지 않을 경우, 발생할 수도 있고, 아닐수도 있다.
-finalize를 통한 자원 파괴는 GC 발생시점이 명확하지 않고, finalize의 호출이 보장되지 않는다.